Important Notes:
The bin code being fed to the Stack starting from the &plaintext adress, is copied to the buffer, thats where we want to have more than 140 byte in order to write our exploit 
inside buf, and then overwrite the locations after the 140, until 140 we reach the lr with return adress of encrypt function, we need to write in little endian additional 4 bytes so we will write 144 byte.
Problem is that the bin code we insert, is being copied to the buffer and the crypted, meaning that our exploit code will not be executable.
We need to crypt bin code with same key before feeding to program.


|
4B
|
----LR ---- &0x100007C4
|
140B
|
----BUF----	&0x10000738
|
|
|
|
----return encrypt &0x8000325



Encrypt in crypto.c, takes the 8 byte from the buffer, and XOR with key[nonce[] % 8], where nonce is an array of random numbers between 0-255.
Lucky for us key has 8 elements and they are all the same, so no matter what nonce is, we will always have key = 0x42.
XOR is a reversible operation, meaning that if we do: 

0x50 XOR 0x42 = 0x12
and now if we want to reverse:
0x12 XOR 0x42 = 0x50

So we just have to XOR before we feed to program, see XOR.py.
When we inject the code we will overwrite the original adress the lr was pointing to in 0x100007c4, with the adress of our buffer.
this will allow the pc to execute our program, but it will not go back to the original return adress: 0x08000325, so it will not keep on working as intended (print the cypher back)
we need to add an instruction at the end of our code, that points the pc back to the original adress.
If we check the code execution in main.c we see that the encrypt return adress the LR originaly points to is &0x8000325, it's enough to moce the pc to point there in order for the task to resume


Injected ASM code:
There are several ways to write the necessary assembly code, to inject, the easiest for me was writing a simple code controlling P1.0 and P1.1, and looking at the generated ASM code in the .lst file.
the code will require some manual fine tuning, and we will have to add the pc point to 0x8000325 manually, but for the rest it will be enough to assemble in little endian at this link:
https://shell-storm.org/online/Online-Assembler-and-Disassembler/

Important note on ledcontrol.c:
By trial and error I noticed that you get a much cleaner and synthesized version of the asm code in the .lst file, if the c code for controlling the leds does NOT rely on the XMCGPIO lib, but on simple register shifting


Final assembly code:

 		ldr	r3, .L3
 		ldr	r3, [r3, #16]
 		ldr	r2, .L3

 		orr	r3, r3, #32768
 		orr	r3, r3, #128
 		str	r3, [r2, #16]



 		ldr	r3, .L3
 		ldr	r3, [r3]
 		ldr	r2, .L3

 		orr	r3, r3, #3
 		str	r3, [r2]

        ldr.w	pc, [pc, #4]
		movs	r0, r0
        movs	r0, r0
        lsls	r5, r4, #12
        lsrs	r0, r0, #32
        .L3:
    	.word	1208123648

Final Hex:
09 4b 1b 69 08 4a 43 f4 00 43 43 f0 80 03 13 61 05 4b 1b 68 04 4a 43 f0 03 03 13 60 df f8 04 f0 00 00 00 00 25 03 00 08 00 81 02 48 