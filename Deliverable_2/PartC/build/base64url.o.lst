   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 1
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.file	"base64url.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.file 1 "base64url.c"
  19              		.section	.text.base64_encode,"ax",%progbits
  20              		.align	1
  21              		.global	base64_encode
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  26              	base64_encode:
  27              	.LVL0:
  28              	.LFB1:
   1:base64url.c   **** /* base64url.c -- Encode binary data using printable characters.
   2:base64url.c   ****    Copyright (C) 1999, 2000, 2001, 2004, 2005, 2006 Free Software
   3:base64url.c   ****    Foundation, Inc.
   4:base64url.c   **** 
   5:base64url.c   ****    This program is free software; you can redistribute it and/or modify
   6:base64url.c   ****    it under the terms of the GNU General Public License as published by
   7:base64url.c   ****    the Free Software Foundation; either version 2, or (at your option)
   8:base64url.c   ****    any later version.
   9:base64url.c   **** 
  10:base64url.c   ****    This program is distributed in the hope that it will be useful,
  11:base64url.c   ****    but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:base64url.c   ****    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:base64url.c   ****    GNU General Public License for more details.
  14:base64url.c   **** 
  15:base64url.c   ****    You should have received a copy of the GNU General Public License
  16:base64url.c   ****    along with this program; if not, write to the Free Software Foundation,
  17:base64url.c   ****    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
  18:base64url.c   **** 
  19:base64url.c   **** /* Written by Simon Josefsson.  Partially adapted from GNU MailUtils
  20:base64url.c   ****  * (mailbox/filter_trans.c, as of 2004-11-28).  Improved by review
  21:base64url.c   ****  * from Paul Eggert, Bruno Haible, and Stepan Kasal.
  22:base64url.c   ****  *
  23:base64url.c   ****  * See also RFC 3548 <http://www.ietf.org/rfc/rfc3548.txt>.
  24:base64url.c   ****  *
  25:base64url.c   ****  * Be careful with error checking.  Here is how you would typically
  26:base64url.c   ****  * use these functions:
  27:base64url.c   ****  *
  28:base64url.c   ****  * bool ok = base64_decode_alloc (in, inlen, &out, &outlen);
  29:base64url.c   ****  * if (!ok)
  30:base64url.c   ****  *   FAIL: input was not valid base64
  31:base64url.c   ****  * if (out == NULL)
  32:base64url.c   ****  *   FAIL: memory allocation error
  33:base64url.c   ****  * OK: data in OUT/OUTLEN
  34:base64url.c   ****  *
  35:base64url.c   ****  * size_t outlen = base64_encode_alloc (in, inlen, &out);
  36:base64url.c   ****  * if (out == NULL && outlen == 0 && inlen != 0)
  37:base64url.c   ****  *   FAIL: input too long
  38:base64url.c   ****  * if (out == NULL)
  39:base64url.c   ****  *   FAIL: memory allocation error
  40:base64url.c   ****  * OK: data in OUT/OUTLEN.
  41:base64url.c   ****  *
  42:base64url.c   ****  */
  43:base64url.c   **** 
  44:base64url.c   **** /* Adapted to URL safe alphabet by Florian Wilde on 2017-12-04
  45:base64url.c   ****  */
  46:base64url.c   **** 
  47:base64url.c   **** //#include <config.h>
  48:base64url.c   **** #include <stdbool.h>
  49:base64url.c   **** 
  50:base64url.c   **** /* Get prototype. */
  51:base64url.c   **** #include "base64url.h"
  52:base64url.c   **** 
  53:base64url.c   **** /* Get malloc. */
  54:base64url.c   **** #include <stdlib.h>
  55:base64url.c   **** 
  56:base64url.c   **** /* Get UCHAR_MAX. */
  57:base64url.c   **** #include <limits.h>
  58:base64url.c   **** 
  59:base64url.c   **** /* C89 compliant way to cast 'char' to 'unsigned char'. */
  60:base64url.c   **** static inline unsigned char
  61:base64url.c   **** to_uchar (char ch)
  62:base64url.c   **** {
  63:base64url.c   ****   return ch;
  64:base64url.c   **** }
  65:base64url.c   **** 
  66:base64url.c   **** /* Base64 encode IN array of size INLEN into OUT array of size OUTLEN.
  67:base64url.c   ****    If OUTLEN is less than BASE64_LENGTH(INLEN), write as many bytes as
  68:base64url.c   ****    possible.  If OUTLEN is larger than BASE64_LENGTH(INLEN), also zero
  69:base64url.c   ****    terminate the output buffer. */
  70:base64url.c   **** void
  71:base64url.c   **** base64_encode (const char *restrict in, size_t inlen,
  72:base64url.c   **** 	       char *restrict out, size_t outlen)
  73:base64url.c   **** {
  29              		.loc 1 73 1 view -0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		.loc 1 73 1 is_stmt 0 view .LVU1
  34 0000 F0B5     		push	{r4, r5, r6, r7, lr}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 20
  37              		.cfi_offset 4, -20
  38              		.cfi_offset 5, -16
  39              		.cfi_offset 6, -12
  40              		.cfi_offset 7, -8
  41              		.cfi_offset 14, -4
  74:base64url.c   ****   static const char b64str[64] =
  42              		.loc 1 74 3 is_stmt 1 view .LVU2
  75:base64url.c   ****     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  76:base64url.c   **** 
  77:base64url.c   ****   while (inlen && outlen)
  43              		.loc 1 77 3 view .LVU3
  44              		.loc 1 77 16 view .LVU4
  45 0002 0029     		cmp	r1, #0
  46 0004 62D0     		beq	.L17
  47 0006 8C46     		mov	ip, r1
  48 0008 0330     		adds	r0, r0, #3
  49              	.LVL1:
  50              		.loc 1 77 16 is_stmt 0 view .LVU5
  51 000a 02F1040E 		add	lr, r2, #4
  52 000e 1C1F     		subs	r4, r3, #4
  78:base64url.c   ****     {
  79:base64url.c   ****       *out++ = b64str[(to_uchar (in[0]) >> 2) & 0x3f];
  53              		.loc 1 79 22 discriminator 1 view .LVU6
  54 0010 2F4D     		ldr	r5, .L22
  55 0012 2EE0     		b	.L3
  56              	.LVL2:
  57              	.L5:
  80:base64url.c   ****       if (!--outlen)
  81:base64url.c   **** 	break;
  82:base64url.c   ****       *out++ = b64str[((to_uchar (in[0]) << 4)
  83:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
  84:base64url.c   **** 		      & 0x3f];
  58              		.loc 1 84 9 view .LVU7
  59 0014 01F03F01 		and	r1, r1, #63
  82:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
  60              		.loc 1 82 14 view .LVU8
  61 0018 2D48     		ldr	r0, .L22
  62              	.LVL3:
  82:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
  63              		.loc 1 82 14 view .LVU9
  64 001a 415C     		ldrb	r1, [r0, r1]	@ zero_extendqisi2
  65 001c 0EF8031C 		strb	r1, [lr, #-3]
  85:base64url.c   ****       if (!--outlen)
  66              		.loc 1 85 7 is_stmt 1 view .LVU10
  67              	.LVL4:
  68              		.loc 1 85 10 is_stmt 0 view .LVU11
  69 0020 022B     		cmp	r3, #2
  70 0022 0BD0     		beq	.L1
  86:base64url.c   **** 	break;
  87:base64url.c   ****       *out++ =
  71              		.loc 1 87 7 is_stmt 1 view .LVU12
  72              	.LVL5:
  73              		.loc 1 87 14 is_stmt 0 discriminator 3 view .LVU13
  74 0024 3D21     		movs	r1, #61
  75 0026 0EF8021C 		strb	r1, [lr, #-2]
  88:base64url.c   **** 	(inlen
  89:base64url.c   **** 	 ? b64str[((to_uchar (in[1]) << 2)
  90:base64url.c   **** 		   + (--inlen ? to_uchar (in[2]) >> 6 : 0))
  91:base64url.c   **** 		  & 0x3f]
  92:base64url.c   **** 	 : '=');
  93:base64url.c   ****       if (!--outlen)
  76              		.loc 1 93 7 is_stmt 1 view .LVU14
  77              	.LVL6:
  78              		.loc 1 93 10 is_stmt 0 view .LVU15
  79 002a 032B     		cmp	r3, #3
  80 002c 06D0     		beq	.L1
  81              	.LVL7:
  82              	.L12:
  94:base64url.c   **** 	break;
  95:base64url.c   ****       *out++ = inlen ? b64str[to_uchar (in[2]) & 0x3f] : '=';
  83              		.loc 1 95 14 discriminator 4 view .LVU16
  84 002e 3D23     		movs	r3, #61
  85 0030 02F8013C 		strb	r3, [r2, #-1]
  96:base64url.c   ****       if (!--outlen)
  86              		.loc 1 96 7 is_stmt 1 view .LVU17
  87              	.LVL8:
  88              		.loc 1 96 10 is_stmt 0 view .LVU18
  89 0034 14B1     		cbz	r4, .L1
  90              	.LVL9:
  91              	.L2:
  97:base64url.c   **** 	break;
  98:base64url.c   ****       if (inlen)
  99:base64url.c   **** 	inlen--;
 100:base64url.c   ****       if (inlen)
 101:base64url.c   **** 	in += 3;
 102:base64url.c   ****     }
 103:base64url.c   **** 
 104:base64url.c   ****   if (outlen)
  92              		.loc 1 104 3 is_stmt 1 view .LVU19
  93              		.loc 1 104 6 is_stmt 0 view .LVU20
  94 0036 0CB1     		cbz	r4, .L1
  95              	.LVL10:
  96              	.L14:
 105:base64url.c   ****     *out = '\0';
  97              		.loc 1 105 5 is_stmt 1 view .LVU21
  98              		.loc 1 105 10 is_stmt 0 view .LVU22
  99 0038 0023     		movs	r3, #0
 100 003a 1370     		strb	r3, [r2]
 101              	.LVL11:
 102              	.L1:
 106:base64url.c   **** }
 103              		.loc 1 106 1 view .LVU23
 104 003c F0BD     		pop	{r4, r5, r6, r7, pc}
 105              	.LVL12:
 106              	.L8:
  91:base64url.c   **** 	 : '=');
 107              		.loc 1 91 5 view .LVU24
 108 003e 01F03F01 		and	r1, r1, #63
  87:base64url.c   **** 	(inlen
 109              		.loc 1 87 14 discriminator 3 view .LVU25
 110 0042 695C     		ldrb	r1, [r5, r1]	@ zero_extendqisi2
 111 0044 0EF8021C 		strb	r1, [lr, #-2]
  93:base64url.c   **** 	break;
 112              		.loc 1 93 7 is_stmt 1 view .LVU26
 113              	.LVL13:
  93:base64url.c   **** 	break;
 114              		.loc 1 93 10 is_stmt 0 view .LVU27
 115 0048 032B     		cmp	r3, #3
 116 004a F7D0     		beq	.L1
  95:base64url.c   ****       if (!--outlen)
 117              		.loc 1 95 7 is_stmt 1 view .LVU28
  95:base64url.c   ****       if (!--outlen)
 118              		.loc 1 95 14 is_stmt 0 view .LVU29
 119 004c 002F     		cmp	r7, #0
 120 004e EED0     		beq	.L12
 121              	.LVL14:
 122              	.L10:
  95:base64url.c   ****       if (!--outlen)
 123              		.loc 1 95 48 discriminator 1 view .LVU30
 124 0050 16F8011C 		ldrb	r1, [r6, #-1]	@ zero_extendqisi2
 125 0054 01F03F01 		and	r1, r1, #63
  95:base64url.c   ****       if (!--outlen)
 126              		.loc 1 95 14 discriminator 4 view .LVU31
 127 0058 695C     		ldrb	r1, [r5, r1]	@ zero_extendqisi2
 128 005a 02F8011C 		strb	r1, [r2, #-1]
  96:base64url.c   **** 	break;
 129              		.loc 1 96 7 is_stmt 1 view .LVU32
 130              	.LVL15:
  96:base64url.c   **** 	break;
 131              		.loc 1 96 10 is_stmt 0 view .LVU33
 132 005e 002C     		cmp	r4, #0
 133 0060 ECD0     		beq	.L1
  99:base64url.c   ****       if (inlen)
 134              		.loc 1 99 2 is_stmt 1 view .LVU34
 135              	.LVL16:
 100:base64url.c   **** 	in += 3;
 136              		.loc 1 100 7 view .LVU35
 100:base64url.c   **** 	in += 3;
 137              		.loc 1 100 10 is_stmt 0 view .LVU36
 138 0062 0330     		adds	r0, r0, #3
 139              	.LVL17:
 100:base64url.c   **** 	in += 3;
 140              		.loc 1 100 10 view .LVU37
 141 0064 043B     		subs	r3, r3, #4
 142 0066 0EF1040E 		add	lr, lr, #4
 143 006a 043C     		subs	r4, r4, #4
 144              	.LVL18:
 100:base64url.c   **** 	in += 3;
 145              		.loc 1 100 10 view .LVU38
 146 006c BCF1030C 		subs	ip, ip, #3
 147              	.LVL19:
 100:base64url.c   **** 	in += 3;
 148              		.loc 1 100 10 view .LVU39
 149 0070 E2D0     		beq	.L14
 150              	.LVL20:
 151              	.L3:
  77:base64url.c   ****     {
 152              		.loc 1 77 16 discriminator 1 view .LVU40
 153 0072 002B     		cmp	r3, #0
 154 0074 E2D0     		beq	.L1
  79:base64url.c   ****       if (!--outlen)
 155              		.loc 1 79 7 is_stmt 1 view .LVU41
 156 0076 0646     		mov	r6, r0
  79:base64url.c   ****       if (!--outlen)
 157              		.loc 1 79 24 is_stmt 0 view .LVU42
 158 0078 10F8031C 		ldrb	r1, [r0, #-3]	@ zero_extendqisi2
 159              	.LVL21:
  79:base64url.c   ****       if (!--outlen)
 160              		.loc 1 79 24 view .LVU43
 161 007c 7246     		mov	r2, lr
  79:base64url.c   ****       if (!--outlen)
 162              		.loc 1 79 47 discriminator 1 view .LVU44
 163 007e 8F08     		lsrs	r7, r1, #2
  79:base64url.c   ****       if (!--outlen)
 164              		.loc 1 79 14 discriminator 1 view .LVU45
 165 0080 EF5D     		ldrb	r7, [r5, r7]	@ zero_extendqisi2
 166 0082 0EF8047C 		strb	r7, [lr, #-4]
  80:base64url.c   **** 	break;
 167              		.loc 1 80 7 is_stmt 1 view .LVU46
 168              	.LVL22:
  80:base64url.c   **** 	break;
 169              		.loc 1 80 10 is_stmt 0 view .LVU47
 170 0086 012B     		cmp	r3, #1
 171 0088 D8D0     		beq	.L1
  82:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
 172              		.loc 1 82 7 is_stmt 1 view .LVU48
  82:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
 173              		.loc 1 82 42 is_stmt 0 discriminator 1 view .LVU49
 174 008a 0901     		lsls	r1, r1, #4
 175              	.LVL23:
  83:base64url.c   **** 		      & 0x3f];
 176              		.loc 1 83 45 view .LVU50
 177 008c BCF1010F 		cmp	ip, #1
 178 0090 C0D0     		beq	.L5
 179              	.LVL24:
  83:base64url.c   **** 		      & 0x3f];
 180              		.loc 1 83 40 discriminator 1 view .LVU51
 181 0092 10F8027C 		ldrb	r7, [r0, #-2]	@ zero_extendqisi2
  83:base64url.c   **** 		      & 0x3f];
 182              		.loc 1 83 10 discriminator 4 view .LVU52
 183 0096 01EB1711 		add	r1, r1, r7, lsr #4
  84:base64url.c   ****       if (!--outlen)
 184              		.loc 1 84 9 view .LVU53
 185 009a 01F03F01 		and	r1, r1, #63
  82:base64url.c   **** 		       + (--inlen ? to_uchar (in[1]) >> 4 : 0))
 186              		.loc 1 82 14 view .LVU54
 187 009e 695C     		ldrb	r1, [r5, r1]	@ zero_extendqisi2
 188 00a0 0EF8031C 		strb	r1, [lr, #-3]
  85:base64url.c   **** 	break;
 189              		.loc 1 85 7 is_stmt 1 view .LVU55
 190              	.LVL25:
  85:base64url.c   **** 	break;
 191              		.loc 1 85 10 is_stmt 0 view .LVU56
 192 00a4 022B     		cmp	r3, #2
 193 00a6 C9D0     		beq	.L1
  89:base64url.c   **** 		   + (--inlen ? to_uchar (in[2]) >> 6 : 0))
 194              		.loc 1 89 14 discriminator 1 view .LVU57
 195 00a8 10F8021C 		ldrb	r1, [r0, #-2]	@ zero_extendqisi2
  89:base64url.c   **** 		   + (--inlen ? to_uchar (in[2]) >> 6 : 0))
 196              		.loc 1 89 31 discriminator 1 view .LVU58
 197 00ac 8900     		lsls	r1, r1, #2
 198              	.LVL26:
  90:base64url.c   **** 		  & 0x3f]
 199              		.loc 1 90 41 view .LVU59
 200 00ae BCF10207 		subs	r7, ip, #2
 201              	.LVL27:
  90:base64url.c   **** 		  & 0x3f]
 202              		.loc 1 90 41 view .LVU60
 203 00b2 C4D0     		beq	.L8
 204              	.LVL28:
  90:base64url.c   **** 		  & 0x3f]
 205              		.loc 1 90 36 discriminator 1 view .LVU61
 206 00b4 10F8017C 		ldrb	r7, [r0, #-1]	@ zero_extendqisi2
 207              	.LVL29:
  90:base64url.c   **** 		  & 0x3f]
 208              		.loc 1 90 6 discriminator 4 view .LVU62
 209 00b8 01EB9711 		add	r1, r1, r7, lsr #6
  91:base64url.c   **** 	 : '=');
 210              		.loc 1 91 5 view .LVU63
 211 00bc 01F03F01 		and	r1, r1, #63
  87:base64url.c   **** 	(inlen
 212              		.loc 1 87 14 discriminator 3 view .LVU64
 213 00c0 695C     		ldrb	r1, [r5, r1]	@ zero_extendqisi2
 214 00c2 0EF8021C 		strb	r1, [lr, #-2]
  93:base64url.c   **** 	break;
 215              		.loc 1 93 7 is_stmt 1 view .LVU65
 216              	.LVL30:
  93:base64url.c   **** 	break;
 217              		.loc 1 93 10 is_stmt 0 view .LVU66
 218 00c6 032B     		cmp	r3, #3
 219 00c8 C2D1     		bne	.L10
 220 00ca B7E7     		b	.L1
 221              	.LVL31:
 222              	.L17:
  77:base64url.c   ****     {
 223              		.loc 1 77 16 view .LVU67
 224 00cc 1C46     		mov	r4, r3
 225 00ce B2E7     		b	.L2
 226              	.L23:
 227              		.align	2
 228              	.L22:
 229 00d0 00000000 		.word	.LANCHOR0
 230              		.cfi_endproc
 231              	.LFE1:
 233              		.section	.text.base64_encode_alloc,"ax",%progbits
 234              		.align	1
 235              		.global	base64_encode_alloc
 236              		.syntax unified
 237              		.thumb
 238              		.thumb_func
 240              	base64_encode_alloc:
 241              	.LVL32:
 242              	.LFB2:
 107:base64url.c   **** 
 108:base64url.c   **** /* Allocate a buffer and store zero terminated base64 encoded data
 109:base64url.c   ****    from array IN of size INLEN, returning BASE64_LENGTH(INLEN), i.e.,
 110:base64url.c   ****    the length of the encoded data, excluding the terminating zero.  On
 111:base64url.c   ****    return, the OUT variable will hold a pointer to newly allocated
 112:base64url.c   ****    memory that must be deallocated by the caller.  If output string
 113:base64url.c   ****    length would overflow, 0 is returned and OUT is set to NULL.  If
 114:base64url.c   ****    memory allocation failed, OUT is set to NULL, and the return value
 115:base64url.c   ****    indicates length of the requested memory block, i.e.,
 116:base64url.c   ****    BASE64_LENGTH(inlen) + 1. */
 117:base64url.c   **** size_t
 118:base64url.c   **** base64_encode_alloc (const char *in, size_t inlen, char **out)
 119:base64url.c   **** {
 243              		.loc 1 119 1 is_stmt 1 view -0
 244              		.cfi_startproc
 245              		@ args = 0, pretend = 0, frame = 0
 246              		@ frame_needed = 0, uses_anonymous_args = 0
 247              		.loc 1 119 1 is_stmt 0 view .LVU69
 248 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 249              	.LCFI1:
 250              		.cfi_def_cfa_offset 24
 251              		.cfi_offset 4, -24
 252              		.cfi_offset 5, -20
 253              		.cfi_offset 6, -16
 254              		.cfi_offset 7, -12
 255              		.cfi_offset 8, -8
 256              		.cfi_offset 14, -4
 257 0004 1646     		mov	r6, r2
 120:base64url.c   ****   size_t outlen = 1 + BASE64_LENGTH (inlen);
 258              		.loc 1 120 3 is_stmt 1 view .LVU70
 259              		.loc 1 120 23 is_stmt 0 view .LVU71
 260 0006 8C1C     		adds	r4, r1, #2
 261 0008 0E4B     		ldr	r3, .L29
 262 000a A3FB0434 		umull	r3, r4, r3, r4
 263 000e 6408     		lsrs	r4, r4, #1
 264 0010 A400     		lsls	r4, r4, #2
 265              		.loc 1 120 10 view .LVU72
 266 0012 04F10108 		add	r8, r4, #1
 267              	.LVL33:
 121:base64url.c   **** 
 122:base64url.c   ****   /* Check for overflow in outlen computation.
 123:base64url.c   ****    *
 124:base64url.c   ****    * If there is no overflow, outlen >= inlen.
 125:base64url.c   ****    *
 126:base64url.c   ****    * If the operation (inlen + 2) overflows then it yields at most +1, so
 127:base64url.c   ****    * outlen is 0.
 128:base64url.c   ****    *
 129:base64url.c   ****    * If the multiplication overflows, we lose at least half of the
 130:base64url.c   ****    * correct value, so the result is < ((inlen + 2) / 3) * 2, which is
 131:base64url.c   ****    * less than (inlen + 2) * 0.66667, which is less than inlen as soon as
 132:base64url.c   ****    * (inlen > 4).
 133:base64url.c   ****    */
 134:base64url.c   ****   if (inlen > outlen)
 268              		.loc 1 134 3 is_stmt 1 view .LVU73
 269              		.loc 1 134 6 is_stmt 0 view .LVU74
 270 0016 4145     		cmp	r1, r8
 271 0018 04D9     		bls	.L25
 135:base64url.c   ****     {
 136:base64url.c   ****       *out = NULL;
 272              		.loc 1 136 7 is_stmt 1 view .LVU75
 273              		.loc 1 136 12 is_stmt 0 view .LVU76
 274 001a 0024     		movs	r4, #0
 275 001c 1460     		str	r4, [r2]
 137:base64url.c   ****       return 0;
 276              		.loc 1 137 7 is_stmt 1 view .LVU77
 277              	.LVL34:
 278              	.L24:
 138:base64url.c   ****     }
 139:base64url.c   **** 
 140:base64url.c   ****   *out = malloc (outlen);
 141:base64url.c   ****   if (!*out)
 142:base64url.c   ****     return outlen;
 143:base64url.c   **** 
 144:base64url.c   ****   base64_encode (in, inlen, *out, outlen);
 145:base64url.c   **** 
 146:base64url.c   ****   return outlen - 1;
 147:base64url.c   **** }
 279              		.loc 1 147 1 is_stmt 0 view .LVU78
 280 001e 2046     		mov	r0, r4
 281 0020 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 282              	.LVL35:
 283              	.L25:
 284              		.loc 1 147 1 view .LVU79
 285 0024 0746     		mov	r7, r0
 286 0026 0D46     		mov	r5, r1
 140:base64url.c   ****   if (!*out)
 287              		.loc 1 140 3 is_stmt 1 view .LVU80
 140:base64url.c   ****   if (!*out)
 288              		.loc 1 140 10 is_stmt 0 view .LVU81
 289 0028 4046     		mov	r0, r8
 290              	.LVL36:
 140:base64url.c   ****   if (!*out)
 291              		.loc 1 140 10 view .LVU82
 292 002a FFF7FEFF 		bl	malloc
 293              	.LVL37:
 140:base64url.c   ****   if (!*out)
 294              		.loc 1 140 10 view .LVU83
 295 002e 0246     		mov	r2, r0
 140:base64url.c   ****   if (!*out)
 296              		.loc 1 140 8 discriminator 1 view .LVU84
 297 0030 3060     		str	r0, [r6]
 141:base64url.c   ****     return outlen;
 298              		.loc 1 141 3 is_stmt 1 view .LVU85
 141:base64url.c   ****     return outlen;
 299              		.loc 1 141 6 is_stmt 0 view .LVU86
 300 0032 28B1     		cbz	r0, .L27
 144:base64url.c   **** 
 301              		.loc 1 144 3 is_stmt 1 view .LVU87
 302 0034 4346     		mov	r3, r8
 303 0036 2946     		mov	r1, r5
 304 0038 3846     		mov	r0, r7
 305 003a FFF7FEFF 		bl	base64_encode
 306              	.LVL38:
 146:base64url.c   **** }
 307              		.loc 1 146 3 view .LVU88
 146:base64url.c   **** }
 308              		.loc 1 146 17 is_stmt 0 view .LVU89
 309 003e EEE7     		b	.L24
 310              	.L27:
 142:base64url.c   **** 
 311              		.loc 1 142 12 view .LVU90
 312 0040 4446     		mov	r4, r8
 313 0042 ECE7     		b	.L24
 314              	.L30:
 315              		.align	2
 316              	.L29:
 317 0044 ABAAAAAA 		.word	-1431655765
 318              		.cfi_endproc
 319              	.LFE2:
 321              		.section	.text.isbase64,"ax",%progbits
 322              		.align	1
 323              		.global	isbase64
 324              		.syntax unified
 325              		.thumb
 326              		.thumb_func
 328              	isbase64:
 329              	.LVL39:
 330              	.LFB3:
 148:base64url.c   **** 
 149:base64url.c   **** /* With this approach this file works independent of the charset used
 150:base64url.c   ****    (think EBCDIC).  However, it does assume that the characters in the
 151:base64url.c   ****    Base64url alphabet (A-Z,a-z,0-9,-,_) are encoded in 0..255.  POSIX
 152:base64url.c   ****    1003.1-2001 require that char and unsigned char are 8-bit
 153:base64url.c   ****    quantities, though, taking care of that problem.  But this may be a
 154:base64url.c   ****    potential problem on non-POSIX C99 platforms.
 155:base64url.c   **** 
 156:base64url.c   ****    IBM C V6 for AIX mishandles "#define B64(x) ...'x'...", so use "_"
 157:base64url.c   ****    as the formal parameter rather than "x".  */
 158:base64url.c   **** #define B64(_)					\
 159:base64url.c   ****   ((_) == 'A' ? 0				\
 160:base64url.c   ****    : (_) == 'B' ? 1				\
 161:base64url.c   ****    : (_) == 'C' ? 2				\
 162:base64url.c   ****    : (_) == 'D' ? 3				\
 163:base64url.c   ****    : (_) == 'E' ? 4				\
 164:base64url.c   ****    : (_) == 'F' ? 5				\
 165:base64url.c   ****    : (_) == 'G' ? 6				\
 166:base64url.c   ****    : (_) == 'H' ? 7				\
 167:base64url.c   ****    : (_) == 'I' ? 8				\
 168:base64url.c   ****    : (_) == 'J' ? 9				\
 169:base64url.c   ****    : (_) == 'K' ? 10				\
 170:base64url.c   ****    : (_) == 'L' ? 11				\
 171:base64url.c   ****    : (_) == 'M' ? 12				\
 172:base64url.c   ****    : (_) == 'N' ? 13				\
 173:base64url.c   ****    : (_) == 'O' ? 14				\
 174:base64url.c   ****    : (_) == 'P' ? 15				\
 175:base64url.c   ****    : (_) == 'Q' ? 16				\
 176:base64url.c   ****    : (_) == 'R' ? 17				\
 177:base64url.c   ****    : (_) == 'S' ? 18				\
 178:base64url.c   ****    : (_) == 'T' ? 19				\
 179:base64url.c   ****    : (_) == 'U' ? 20				\
 180:base64url.c   ****    : (_) == 'V' ? 21				\
 181:base64url.c   ****    : (_) == 'W' ? 22				\
 182:base64url.c   ****    : (_) == 'X' ? 23				\
 183:base64url.c   ****    : (_) == 'Y' ? 24				\
 184:base64url.c   ****    : (_) == 'Z' ? 25				\
 185:base64url.c   ****    : (_) == 'a' ? 26				\
 186:base64url.c   ****    : (_) == 'b' ? 27				\
 187:base64url.c   ****    : (_) == 'c' ? 28				\
 188:base64url.c   ****    : (_) == 'd' ? 29				\
 189:base64url.c   ****    : (_) == 'e' ? 30				\
 190:base64url.c   ****    : (_) == 'f' ? 31				\
 191:base64url.c   ****    : (_) == 'g' ? 32				\
 192:base64url.c   ****    : (_) == 'h' ? 33				\
 193:base64url.c   ****    : (_) == 'i' ? 34				\
 194:base64url.c   ****    : (_) == 'j' ? 35				\
 195:base64url.c   ****    : (_) == 'k' ? 36				\
 196:base64url.c   ****    : (_) == 'l' ? 37				\
 197:base64url.c   ****    : (_) == 'm' ? 38				\
 198:base64url.c   ****    : (_) == 'n' ? 39				\
 199:base64url.c   ****    : (_) == 'o' ? 40				\
 200:base64url.c   ****    : (_) == 'p' ? 41				\
 201:base64url.c   ****    : (_) == 'q' ? 42				\
 202:base64url.c   ****    : (_) == 'r' ? 43				\
 203:base64url.c   ****    : (_) == 's' ? 44				\
 204:base64url.c   ****    : (_) == 't' ? 45				\
 205:base64url.c   ****    : (_) == 'u' ? 46				\
 206:base64url.c   ****    : (_) == 'v' ? 47				\
 207:base64url.c   ****    : (_) == 'w' ? 48				\
 208:base64url.c   ****    : (_) == 'x' ? 49				\
 209:base64url.c   ****    : (_) == 'y' ? 50				\
 210:base64url.c   ****    : (_) == 'z' ? 51				\
 211:base64url.c   ****    : (_) == '0' ? 52				\
 212:base64url.c   ****    : (_) == '1' ? 53				\
 213:base64url.c   ****    : (_) == '2' ? 54				\
 214:base64url.c   ****    : (_) == '3' ? 55				\
 215:base64url.c   ****    : (_) == '4' ? 56				\
 216:base64url.c   ****    : (_) == '5' ? 57				\
 217:base64url.c   ****    : (_) == '6' ? 58				\
 218:base64url.c   ****    : (_) == '7' ? 59				\
 219:base64url.c   ****    : (_) == '8' ? 60				\
 220:base64url.c   ****    : (_) == '9' ? 61				\
 221:base64url.c   ****    : (_) == '-' ? 62				\
 222:base64url.c   ****    : (_) == '_' ? 63				\
 223:base64url.c   ****    : -1)
 224:base64url.c   **** 
 225:base64url.c   **** static const signed char b64[0x100] = {
 226:base64url.c   ****   B64 (0), B64 (1), B64 (2), B64 (3),
 227:base64url.c   ****   B64 (4), B64 (5), B64 (6), B64 (7),
 228:base64url.c   ****   B64 (8), B64 (9), B64 (10), B64 (11),
 229:base64url.c   ****   B64 (12), B64 (13), B64 (14), B64 (15),
 230:base64url.c   ****   B64 (16), B64 (17), B64 (18), B64 (19),
 231:base64url.c   ****   B64 (20), B64 (21), B64 (22), B64 (23),
 232:base64url.c   ****   B64 (24), B64 (25), B64 (26), B64 (27),
 233:base64url.c   ****   B64 (28), B64 (29), B64 (30), B64 (31),
 234:base64url.c   ****   B64 (32), B64 (33), B64 (34), B64 (35),
 235:base64url.c   ****   B64 (36), B64 (37), B64 (38), B64 (39),
 236:base64url.c   ****   B64 (40), B64 (41), B64 (42), B64 (43),
 237:base64url.c   ****   B64 (44), B64 (45), B64 (46), B64 (47),
 238:base64url.c   ****   B64 (48), B64 (49), B64 (50), B64 (51),
 239:base64url.c   ****   B64 (52), B64 (53), B64 (54), B64 (55),
 240:base64url.c   ****   B64 (56), B64 (57), B64 (58), B64 (59),
 241:base64url.c   ****   B64 (60), B64 (61), B64 (62), B64 (63),
 242:base64url.c   ****   B64 (64), B64 (65), B64 (66), B64 (67),
 243:base64url.c   ****   B64 (68), B64 (69), B64 (70), B64 (71),
 244:base64url.c   ****   B64 (72), B64 (73), B64 (74), B64 (75),
 245:base64url.c   ****   B64 (76), B64 (77), B64 (78), B64 (79),
 246:base64url.c   ****   B64 (80), B64 (81), B64 (82), B64 (83),
 247:base64url.c   ****   B64 (84), B64 (85), B64 (86), B64 (87),
 248:base64url.c   ****   B64 (88), B64 (89), B64 (90), B64 (91),
 249:base64url.c   ****   B64 (92), B64 (93), B64 (94), B64 (95),
 250:base64url.c   ****   B64 (96), B64 (97), B64 (98), B64 (99),
 251:base64url.c   ****   B64 (100), B64 (101), B64 (102), B64 (103),
 252:base64url.c   ****   B64 (104), B64 (105), B64 (106), B64 (107),
 253:base64url.c   ****   B64 (108), B64 (109), B64 (110), B64 (111),
 254:base64url.c   ****   B64 (112), B64 (113), B64 (114), B64 (115),
 255:base64url.c   ****   B64 (116), B64 (117), B64 (118), B64 (119),
 256:base64url.c   ****   B64 (120), B64 (121), B64 (122), B64 (123),
 257:base64url.c   ****   B64 (124), B64 (125), B64 (126), B64 (127),
 258:base64url.c   ****   B64 (128), B64 (129), B64 (130), B64 (131),
 259:base64url.c   ****   B64 (132), B64 (133), B64 (134), B64 (135),
 260:base64url.c   ****   B64 (136), B64 (137), B64 (138), B64 (139),
 261:base64url.c   ****   B64 (140), B64 (141), B64 (142), B64 (143),
 262:base64url.c   ****   B64 (144), B64 (145), B64 (146), B64 (147),
 263:base64url.c   ****   B64 (148), B64 (149), B64 (150), B64 (151),
 264:base64url.c   ****   B64 (152), B64 (153), B64 (154), B64 (155),
 265:base64url.c   ****   B64 (156), B64 (157), B64 (158), B64 (159),
 266:base64url.c   ****   B64 (160), B64 (161), B64 (162), B64 (163),
 267:base64url.c   ****   B64 (164), B64 (165), B64 (166), B64 (167),
 268:base64url.c   ****   B64 (168), B64 (169), B64 (170), B64 (171),
 269:base64url.c   ****   B64 (172), B64 (173), B64 (174), B64 (175),
 270:base64url.c   ****   B64 (176), B64 (177), B64 (178), B64 (179),
 271:base64url.c   ****   B64 (180), B64 (181), B64 (182), B64 (183),
 272:base64url.c   ****   B64 (184), B64 (185), B64 (186), B64 (187),
 273:base64url.c   ****   B64 (188), B64 (189), B64 (190), B64 (191),
 274:base64url.c   ****   B64 (192), B64 (193), B64 (194), B64 (195),
 275:base64url.c   ****   B64 (196), B64 (197), B64 (198), B64 (199),
 276:base64url.c   ****   B64 (200), B64 (201), B64 (202), B64 (203),
 277:base64url.c   ****   B64 (204), B64 (205), B64 (206), B64 (207),
 278:base64url.c   ****   B64 (208), B64 (209), B64 (210), B64 (211),
 279:base64url.c   ****   B64 (212), B64 (213), B64 (214), B64 (215),
 280:base64url.c   ****   B64 (216), B64 (217), B64 (218), B64 (219),
 281:base64url.c   ****   B64 (220), B64 (221), B64 (222), B64 (223),
 282:base64url.c   ****   B64 (224), B64 (225), B64 (226), B64 (227),
 283:base64url.c   ****   B64 (228), B64 (229), B64 (230), B64 (231),
 284:base64url.c   ****   B64 (232), B64 (233), B64 (234), B64 (235),
 285:base64url.c   ****   B64 (236), B64 (237), B64 (238), B64 (239),
 286:base64url.c   ****   B64 (240), B64 (241), B64 (242), B64 (243),
 287:base64url.c   ****   B64 (244), B64 (245), B64 (246), B64 (247),
 288:base64url.c   ****   B64 (248), B64 (249), B64 (250), B64 (251),
 289:base64url.c   ****   B64 (252), B64 (253), B64 (254), B64 (255)
 290:base64url.c   **** };
 291:base64url.c   **** 
 292:base64url.c   **** #if UCHAR_MAX == 255
 293:base64url.c   **** # define uchar_in_range(c) true
 294:base64url.c   **** #else
 295:base64url.c   **** # define uchar_in_range(c) ((c) <= 255)
 296:base64url.c   **** #endif
 297:base64url.c   **** 
 298:base64url.c   **** /* Return true if CH is a character from the Base64 alphabet, and
 299:base64url.c   ****    false otherwise.  Note that '=' is padding and not considered to be
 300:base64url.c   ****    part of the alphabet.  */
 301:base64url.c   **** bool
 302:base64url.c   **** isbase64 (char ch)
 303:base64url.c   **** {
 331              		.loc 1 303 1 is_stmt 1 view -0
 332              		.cfi_startproc
 333              		@ args = 0, pretend = 0, frame = 0
 334              		@ frame_needed = 0, uses_anonymous_args = 0
 335              		@ link register save eliminated.
 304:base64url.c   ****   return uchar_in_range (to_uchar (ch)) && 0 <= b64[to_uchar (ch)];
 336              		.loc 1 304 3 view .LVU92
 337              		.loc 1 304 52 is_stmt 0 discriminator 1 view .LVU93
 338 0000 034B     		ldr	r3, .L32
 339 0002 0344     		add	r3, r3, r0
 340              		.loc 1 304 41 discriminator 1 view .LVU94
 341 0004 93F84000 		ldrb	r0, [r3, #64]	@ zero_extendqisi2
 342              	.LVL40:
 343              		.loc 1 304 41 discriminator 1 view .LVU95
 344 0008 C043     		mvns	r0, r0
 305:base64url.c   **** }
 345              		.loc 1 305 1 view .LVU96
 346 000a C0F3C010 		ubfx	r0, r0, #7, #1
 347 000e 7047     		bx	lr
 348              	.L33:
 349              		.align	2
 350              	.L32:
 351 0010 00000000 		.word	.LANCHOR0
 352              		.cfi_endproc
 353              	.LFE3:
 355              		.section	.text.base64_decode,"ax",%progbits
 356              		.align	1
 357              		.global	base64_decode
 358              		.syntax unified
 359              		.thumb
 360              		.thumb_func
 362              	base64_decode:
 363              	.LVL41:
 364              	.LFB4:
 306:base64url.c   **** 
 307:base64url.c   **** /* Decode base64 encoded input array IN of length INLEN to output
 308:base64url.c   ****    array OUT that can hold *OUTLEN bytes.  Return true if decoding was
 309:base64url.c   ****    successful, i.e. if the input was valid base64 data, false
 310:base64url.c   ****    otherwise.  If *OUTLEN is too small, as many bytes as possible will
 311:base64url.c   ****    be written to OUT.  On return, *OUTLEN holds the length of decoded
 312:base64url.c   ****    bytes in OUT.  Note that as soon as any non-alphabet characters are
 313:base64url.c   ****    encountered, decoding is stopped and false is returned.  This means
 314:base64url.c   ****    that, when applicable, you must remove any line terminators that is
 315:base64url.c   ****    part of the data stream before calling this function.  */
 316:base64url.c   **** bool
 317:base64url.c   **** base64_decode (const char *restrict in, size_t inlen,
 318:base64url.c   **** 	       char *restrict out, size_t *outlen)
 319:base64url.c   **** {
 365              		.loc 1 319 1 is_stmt 1 view -0
 366              		.cfi_startproc
 367              		@ args = 0, pretend = 0, frame = 0
 368              		@ frame_needed = 0, uses_anonymous_args = 0
 369              		.loc 1 319 1 is_stmt 0 view .LVU98
 370 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 371              	.LCFI2:
 372              		.cfi_def_cfa_offset 20
 373              		.cfi_offset 4, -20
 374              		.cfi_offset 5, -16
 375              		.cfi_offset 6, -12
 376              		.cfi_offset 7, -8
 377              		.cfi_offset 14, -4
 320:base64url.c   ****   size_t outleft = *outlen;
 378              		.loc 1 320 3 is_stmt 1 view .LVU99
 379              		.loc 1 320 10 is_stmt 0 view .LVU100
 380 0002 1E68     		ldr	r6, [r3]
 381              	.LVL42:
 321:base64url.c   **** 
 322:base64url.c   ****   while (inlen >= 2)
 382              		.loc 1 322 3 is_stmt 1 view .LVU101
 383              		.loc 1 322 16 view .LVU102
 384 0004 0129     		cmp	r1, #1
 385 0006 53D9     		bls	.L43
 320:base64url.c   ****   size_t outleft = *outlen;
 386              		.loc 1 320 10 is_stmt 0 view .LVU103
 387 0008 3446     		mov	r4, r6
 388              	.LBB36:
 389              	.LBB37:
 304:base64url.c   **** }
 390              		.loc 1 304 52 discriminator 1 view .LVU104
 391 000a 2A4D     		ldr	r5, .L49
 392 000c 12E0     		b	.L42
 393              	.LVL43:
 394              	.L47:
 304:base64url.c   **** }
 395              		.loc 1 304 52 discriminator 1 view .LVU105
 396              	.LBE37:
 397              	.LBE36:
 323:base64url.c   ****     {
 324:base64url.c   ****       if (!isbase64 (in[0]) || !isbase64 (in[1]))
 325:base64url.c   **** 	break;
 326:base64url.c   **** 
 327:base64url.c   ****       if (outleft)
 328:base64url.c   **** 	{
 329:base64url.c   **** 	  *out++ = ((b64[to_uchar (in[0])] << 2)
 330:base64url.c   **** 		    | (b64[to_uchar (in[1])] >> 4));
 331:base64url.c   **** 	  outleft--;
 332:base64url.c   **** 	}
 333:base64url.c   **** 
 334:base64url.c   ****       if (inlen == 2)
 335:base64url.c   **** 	break;
 336:base64url.c   **** 
 337:base64url.c   ****       if (in[2] == '=')
 338:base64url.c   **** 	{
 339:base64url.c   **** 	  if (inlen != 4)
 398              		.loc 1 339 4 is_stmt 1 view .LVU106
 399              		.loc 1 339 7 is_stmt 0 view .LVU107
 400 000e 0429     		cmp	r1, #4
 401 0010 03D1     		bne	.L35
 340:base64url.c   **** 	    break;
 341:base64url.c   **** 
 342:base64url.c   **** 	  if (in[3] != '=')
 402              		.loc 1 342 4 is_stmt 1 view .LVU108
 403              		.loc 1 342 7 is_stmt 0 view .LVU109
 404 0012 C278     		ldrb	r2, [r0, #3]	@ zero_extendqisi2
 405              	.LVL44:
 406              		.loc 1 342 7 view .LVU110
 407 0014 3D2A     		cmp	r2, #61
 408 0016 00D1     		bne	.L35
 409              	.LVL45:
 410              	.L38:
 343:base64url.c   **** 	    break;
 344:base64url.c   **** 
 345:base64url.c   **** 	}
 346:base64url.c   ****       else
 347:base64url.c   **** 	{
 348:base64url.c   **** 	  if (!isbase64 (in[2]))
 349:base64url.c   **** 	    break;
 350:base64url.c   **** 
 351:base64url.c   **** 	  if (outleft)
 352:base64url.c   **** 	    {
 353:base64url.c   **** 	      *out++ = (((b64[to_uchar (in[1])] << 4) & 0xf0)
 354:base64url.c   **** 			| (b64[to_uchar (in[2])] >> 2));
 355:base64url.c   **** 	      outleft--;
 356:base64url.c   **** 	    }
 357:base64url.c   **** 
 358:base64url.c   **** 	  if (inlen == 3)
 359:base64url.c   **** 	    break;
 360:base64url.c   **** 
 361:base64url.c   **** 	  if (in[3] == '=')
 362:base64url.c   **** 	    {
 363:base64url.c   **** 	      if (inlen != 4)
 364:base64url.c   **** 		break;
 365:base64url.c   **** 	    }
 366:base64url.c   **** 	  else
 367:base64url.c   **** 	    {
 368:base64url.c   **** 	      if (!isbase64 (in[3]))
 369:base64url.c   **** 		break;
 370:base64url.c   **** 
 371:base64url.c   **** 	      if (outleft)
 372:base64url.c   **** 		{
 373:base64url.c   **** 		  *out++ = (((b64[to_uchar (in[2])] << 6) & 0xc0)
 374:base64url.c   **** 			    | b64[to_uchar (in[3])]);
 375:base64url.c   **** 		  outleft--;
 376:base64url.c   **** 		}
 377:base64url.c   **** 	    }
 378:base64url.c   **** 	}
 379:base64url.c   **** 
 380:base64url.c   ****       in += 4;
 411              		.loc 1 380 7 is_stmt 1 view .LVU111
 381:base64url.c   ****       inlen -= 4;
 412              		.loc 1 381 7 view .LVU112
 322:base64url.c   ****     {
 413              		.loc 1 322 16 view .LVU113
 414              		.loc 1 381 13 is_stmt 0 view .LVU114
 415 0018 0021     		movs	r1, #0
 416              	.LVL46:
 417              	.L35:
 382:base64url.c   ****     }
 383:base64url.c   **** 
 384:base64url.c   ****   *outlen -= outleft;
 418              		.loc 1 384 3 is_stmt 1 view .LVU115
 419              		.loc 1 384 11 is_stmt 0 view .LVU116
 420 001a 341B     		subs	r4, r6, r4
 421              	.LVL47:
 422              		.loc 1 384 11 view .LVU117
 423 001c 1C60     		str	r4, [r3]
 385:base64url.c   **** 
 386:base64url.c   ****   if (inlen != 0)
 424              		.loc 1 386 3 is_stmt 1 view .LVU118
 387:base64url.c   ****     return false;
 388:base64url.c   **** 
 389:base64url.c   ****   return true;
 390:base64url.c   **** }
 425              		.loc 1 390 1 is_stmt 0 view .LVU119
 426 001e B1FA81F0 		clz	r0, r1
 427 0022 4009     		lsrs	r0, r0, #5
 428 0024 F0BD     		pop	{r4, r5, r6, r7, pc}
 429              	.LVL48:
 430              	.L48:
 363:base64url.c   **** 		break;
 431              		.loc 1 363 8 is_stmt 1 view .LVU120
 363:base64url.c   **** 		break;
 432              		.loc 1 363 11 is_stmt 0 view .LVU121
 433 0026 0429     		cmp	r1, #4
 434 0028 F6D0     		beq	.L38
 363:base64url.c   **** 		break;
 435              		.loc 1 363 11 view .LVU122
 436 002a F6E7     		b	.L35
 437              	.L41:
 380:base64url.c   ****       inlen -= 4;
 438              		.loc 1 380 7 is_stmt 1 view .LVU123
 439              	.LVL49:
 380:base64url.c   ****       inlen -= 4;
 440              		.loc 1 380 10 is_stmt 0 view .LVU124
 441 002c 0430     		adds	r0, r0, #4
 442              	.LVL50:
 381:base64url.c   ****     }
 443              		.loc 1 381 7 is_stmt 1 view .LVU125
 381:base64url.c   ****     }
 444              		.loc 1 381 13 is_stmt 0 view .LVU126
 445 002e 0439     		subs	r1, r1, #4
 446              	.LVL51:
 322:base64url.c   ****     {
 447              		.loc 1 322 16 is_stmt 1 view .LVU127
 448 0030 0129     		cmp	r1, #1
 449 0032 F2D9     		bls	.L35
 450              	.L42:
 324:base64url.c   **** 	break;
 451              		.loc 1 324 7 view .LVU128
 452              	.LVL52:
 453              	.LBB39:
 454              	.LBI36:
 302:base64url.c   **** {
 455              		.loc 1 302 1 view .LVU129
 456              	.LBB38:
 304:base64url.c   **** }
 457              		.loc 1 304 3 view .LVU130
 304:base64url.c   **** }
 458              		.loc 1 304 53 is_stmt 0 discriminator 1 view .LVU131
 459 0034 90F800C0 		ldrb	ip, [r0]	@ zero_extendqisi2
 304:base64url.c   **** }
 460              		.loc 1 304 52 discriminator 1 view .LVU132
 461 0038 AC44     		add	ip, ip, r5
 462 003a 9CF94070 		ldrsb	r7, [ip, #64]
 463              	.LVL53:
 304:base64url.c   **** }
 464              		.loc 1 304 52 discriminator 1 view .LVU133
 465              	.LBE38:
 466              	.LBE39:
 324:base64url.c   **** 	break;
 467              		.loc 1 324 10 discriminator 1 view .LVU134
 468 003e 002F     		cmp	r7, #0
 469 0040 EBDB     		blt	.L35
 470              	.LVL54:
 471              	.LBB40:
 472              	.LBI40:
 302:base64url.c   **** {
 473              		.loc 1 302 1 is_stmt 1 view .LVU135
 474              	.LBB41:
 304:base64url.c   **** }
 475              		.loc 1 304 3 view .LVU136
 304:base64url.c   **** }
 476              		.loc 1 304 53 is_stmt 0 discriminator 1 view .LVU137
 477 0042 90F801C0 		ldrb	ip, [r0, #1]	@ zero_extendqisi2
 304:base64url.c   **** }
 478              		.loc 1 304 52 discriminator 1 view .LVU138
 479 0046 AC44     		add	ip, ip, r5
 480 0048 9CF940E0 		ldrsb	lr, [ip, #64]
 481              	.LVL55:
 304:base64url.c   **** }
 482              		.loc 1 304 52 discriminator 1 view .LVU139
 483              	.LBE41:
 484              	.LBE40:
 324:base64url.c   **** 	break;
 485              		.loc 1 324 29 discriminator 1 view .LVU140
 486 004c BEF1000F 		cmp	lr, #0
 487 0050 E3DB     		blt	.L35
 327:base64url.c   **** 	{
 488              		.loc 1 327 7 is_stmt 1 view .LVU141
 327:base64url.c   **** 	{
 489              		.loc 1 327 10 is_stmt 0 view .LVU142
 490 0052 34B1     		cbz	r4, .L36
 329:base64url.c   **** 		    | (b64[to_uchar (in[1])] >> 4));
 491              		.loc 1 329 4 is_stmt 1 view .LVU143
 492              	.LVL56:
 330:base64url.c   **** 	  outleft--;
 493              		.loc 1 330 7 is_stmt 0 discriminator 1 view .LVU144
 494 0054 4FEA2E1C 		asr	ip, lr, #4
 495 0058 4CEA8707 		orr	r7, ip, r7, lsl #2
 329:base64url.c   **** 		    | (b64[to_uchar (in[1])] >> 4));
 496              		.loc 1 329 11 view .LVU145
 497 005c 02F8017B 		strb	r7, [r2], #1
 498              	.LVL57:
 331:base64url.c   **** 	}
 499              		.loc 1 331 4 is_stmt 1 view .LVU146
 331:base64url.c   **** 	}
 500              		.loc 1 331 11 is_stmt 0 view .LVU147
 501 0060 013C     		subs	r4, r4, #1
 502              	.LVL58:
 503              	.L36:
 334:base64url.c   **** 	break;
 504              		.loc 1 334 7 is_stmt 1 view .LVU148
 334:base64url.c   **** 	break;
 505              		.loc 1 334 10 is_stmt 0 view .LVU149
 506 0062 0229     		cmp	r1, #2
 507 0064 D9D0     		beq	.L35
 337:base64url.c   **** 	{
 508              		.loc 1 337 7 is_stmt 1 view .LVU150
 337:base64url.c   **** 	{
 509              		.loc 1 337 13 is_stmt 0 view .LVU151
 510 0066 90F802C0 		ldrb	ip, [r0, #2]	@ zero_extendqisi2
 337:base64url.c   **** 	{
 511              		.loc 1 337 10 view .LVU152
 512 006a BCF13D0F 		cmp	ip, #61
 513 006e CED0     		beq	.L47
 348:base64url.c   **** 	    break;
 514              		.loc 1 348 4 is_stmt 1 view .LVU153
 515              	.LVL59:
 516              	.LBB42:
 517              	.LBI42:
 302:base64url.c   **** {
 518              		.loc 1 302 1 view .LVU154
 519              	.LBB43:
 304:base64url.c   **** }
 520              		.loc 1 304 3 view .LVU155
 304:base64url.c   **** }
 521              		.loc 1 304 52 is_stmt 0 discriminator 1 view .LVU156
 522 0070 AC44     		add	ip, ip, r5
 523              	.LVL60:
 304:base64url.c   **** }
 524              		.loc 1 304 52 discriminator 1 view .LVU157
 525 0072 9CF940C0 		ldrsb	ip, [ip, #64]
 526              	.LVL61:
 304:base64url.c   **** }
 527              		.loc 1 304 52 discriminator 1 view .LVU158
 528              	.LBE43:
 529              	.LBE42:
 348:base64url.c   **** 	    break;
 530              		.loc 1 348 7 discriminator 1 view .LVU159
 531 0076 BCF1000F 		cmp	ip, #0
 532 007a CEDB     		blt	.L35
 351:base64url.c   **** 	    {
 533              		.loc 1 351 4 is_stmt 1 view .LVU160
 351:base64url.c   **** 	    {
 534              		.loc 1 351 7 is_stmt 0 view .LVU161
 535 007c 34B1     		cbz	r4, .L39
 353:base64url.c   **** 			| (b64[to_uchar (in[2])] >> 2));
 536              		.loc 1 353 8 is_stmt 1 view .LVU162
 537              	.LVL62:
 354:base64url.c   **** 	      outleft--;
 538              		.loc 1 354 4 is_stmt 0 discriminator 1 view .LVU163
 539 007e 4FEAAC07 		asr	r7, ip, #2
 540 0082 47EA0E17 		orr	r7, r7, lr, lsl #4
 353:base64url.c   **** 			| (b64[to_uchar (in[2])] >> 2));
 541              		.loc 1 353 15 view .LVU164
 542 0086 02F8017B 		strb	r7, [r2], #1
 543              	.LVL63:
 355:base64url.c   **** 	    }
 544              		.loc 1 355 8 is_stmt 1 view .LVU165
 355:base64url.c   **** 	    }
 545              		.loc 1 355 15 is_stmt 0 view .LVU166
 546 008a 013C     		subs	r4, r4, #1
 547              	.LVL64:
 548              	.L39:
 358:base64url.c   **** 	    break;
 549              		.loc 1 358 4 is_stmt 1 view .LVU167
 358:base64url.c   **** 	    break;
 550              		.loc 1 358 7 is_stmt 0 view .LVU168
 551 008c 0329     		cmp	r1, #3
 552 008e C4D0     		beq	.L35
 361:base64url.c   **** 	    {
 553              		.loc 1 361 4 is_stmt 1 view .LVU169
 361:base64url.c   **** 	    {
 554              		.loc 1 361 10 is_stmt 0 view .LVU170
 555 0090 C778     		ldrb	r7, [r0, #3]	@ zero_extendqisi2
 361:base64url.c   **** 	    {
 556              		.loc 1 361 7 view .LVU171
 557 0092 3D2F     		cmp	r7, #61
 558 0094 C7D0     		beq	.L48
 368:base64url.c   **** 		break;
 559              		.loc 1 368 8 is_stmt 1 view .LVU172
 560              	.LVL65:
 561              	.LBB44:
 562              	.LBI44:
 302:base64url.c   **** {
 563              		.loc 1 302 1 view .LVU173
 564              	.LBB45:
 304:base64url.c   **** }
 565              		.loc 1 304 3 view .LVU174
 304:base64url.c   **** }
 566              		.loc 1 304 52 is_stmt 0 discriminator 1 view .LVU175
 567 0096 2F44     		add	r7, r7, r5
 568              	.LVL66:
 304:base64url.c   **** }
 569              		.loc 1 304 52 discriminator 1 view .LVU176
 570 0098 97F94070 		ldrsb	r7, [r7, #64]
 571              	.LVL67:
 304:base64url.c   **** }
 572              		.loc 1 304 52 discriminator 1 view .LVU177
 573              	.LBE45:
 574              	.LBE44:
 368:base64url.c   **** 		break;
 575              		.loc 1 368 11 discriminator 1 view .LVU178
 576 009c 002F     		cmp	r7, #0
 577 009e BCDB     		blt	.L35
 371:base64url.c   **** 		{
 578              		.loc 1 371 8 is_stmt 1 view .LVU179
 371:base64url.c   **** 		{
 579              		.loc 1 371 11 is_stmt 0 view .LVU180
 580 00a0 002C     		cmp	r4, #0
 581 00a2 C3D0     		beq	.L41
 373:base64url.c   **** 			    | b64[to_uchar (in[3])]);
 582              		.loc 1 373 5 is_stmt 1 view .LVU181
 583              	.LVL68:
 374:base64url.c   **** 		  outleft--;
 584              		.loc 1 374 8 is_stmt 0 discriminator 1 view .LVU182
 585 00a4 47EA8C17 		orr	r7, r7, ip, lsl #6
 373:base64url.c   **** 			    | b64[to_uchar (in[3])]);
 586              		.loc 1 373 12 view .LVU183
 587 00a8 02F8017B 		strb	r7, [r2], #1
 588              	.LVL69:
 375:base64url.c   **** 		}
 589              		.loc 1 375 5 is_stmt 1 view .LVU184
 375:base64url.c   **** 		}
 590              		.loc 1 375 12 is_stmt 0 view .LVU185
 591 00ac 013C     		subs	r4, r4, #1
 592              	.LVL70:
 375:base64url.c   **** 		}
 593              		.loc 1 375 12 view .LVU186
 594 00ae BDE7     		b	.L41
 595              	.LVL71:
 596              	.L43:
 320:base64url.c   **** 
 597              		.loc 1 320 10 view .LVU187
 598 00b0 3446     		mov	r4, r6
 599 00b2 B2E7     		b	.L35
 600              	.L50:
 601              		.align	2
 602              	.L49:
 603 00b4 00000000 		.word	.LANCHOR0
 604              		.cfi_endproc
 605              	.LFE4:
 607              		.section	.text.base64_decode_alloc,"ax",%progbits
 608              		.align	1
 609              		.global	base64_decode_alloc
 610              		.syntax unified
 611              		.thumb
 612              		.thumb_func
 614              	base64_decode_alloc:
 615              	.LVL72:
 616              	.LFB5:
 391:base64url.c   **** 
 392:base64url.c   **** /* Allocate an output buffer in *OUT, and decode the base64 encoded
 393:base64url.c   ****    data stored in IN of size INLEN to the *OUT buffer.  On return, the
 394:base64url.c   ****    size of the decoded data is stored in *OUTLEN.  OUTLEN may be NULL,
 395:base64url.c   ****    if the caller is not interested in the decoded length.  *OUT may be
 396:base64url.c   ****    NULL to indicate an out of memory error, in which case *OUTLEN
 397:base64url.c   ****    contains the size of the memory block needed.  The function returns
 398:base64url.c   ****    true on successful decoding and memory allocation errors.  (Use the
 399:base64url.c   ****    *OUT and *OUTLEN parameters to differentiate between successful
 400:base64url.c   ****    decoding and memory error.)  The function returns false if the
 401:base64url.c   ****    input was invalid, in which case *OUT is NULL and *OUTLEN is
 402:base64url.c   ****    undefined. */
 403:base64url.c   **** bool
 404:base64url.c   **** base64_decode_alloc (const char *in, size_t inlen, char **out,
 405:base64url.c   **** 		     size_t *outlen)
 406:base64url.c   **** {
 617              		.loc 1 406 1 is_stmt 1 view -0
 618              		.cfi_startproc
 619              		@ args = 0, pretend = 0, frame = 8
 620              		@ frame_needed = 0, uses_anonymous_args = 0
 621              		.loc 1 406 1 is_stmt 0 view .LVU189
 622 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 623              	.LCFI3:
 624              		.cfi_def_cfa_offset 20
 625              		.cfi_offset 4, -20
 626              		.cfi_offset 5, -16
 627              		.cfi_offset 6, -12
 628              		.cfi_offset 7, -8
 629              		.cfi_offset 14, -4
 630 0002 83B0     		sub	sp, sp, #12
 631              	.LCFI4:
 632              		.cfi_def_cfa_offset 32
 633 0004 0746     		mov	r7, r0
 634 0006 0C46     		mov	r4, r1
 635 0008 1546     		mov	r5, r2
 636 000a 1E46     		mov	r6, r3
 407:base64url.c   ****   /* This may allocate a few bytes too much, depending on input,
 408:base64url.c   ****      but it's not worth the extra CPU time to compute the exact amount.
 409:base64url.c   ****      The exact amount is 3 * inlen / 4, minus 1 if the input ends
 410:base64url.c   ****      with "=" and minus another 1 if the input ends with "==".
 411:base64url.c   ****      Dividing before multiplying avoids the possibility of overflow.  */
 412:base64url.c   ****   size_t needlen = 3 * (inlen / 4) + 2;
 637              		.loc 1 412 3 is_stmt 1 view .LVU190
 638              		.loc 1 412 31 is_stmt 0 view .LVU191
 639 000c 4FEA910C 		lsr	ip, r1, #2
 640              		.loc 1 412 22 view .LVU192
 641 0010 0CEB4C0C 		add	ip, ip, ip, lsl #1
 642              		.loc 1 412 36 view .LVU193
 643 0014 0CF10200 		add	r0, ip, #2
 644              	.LVL73:
 645              		.loc 1 412 10 view .LVU194
 646 0018 0190     		str	r0, [sp, #4]
 413:base64url.c   **** 
 414:base64url.c   ****   *out = malloc (needlen);
 647              		.loc 1 414 3 is_stmt 1 view .LVU195
 648              		.loc 1 414 10 is_stmt 0 view .LVU196
 649 001a FFF7FEFF 		bl	malloc
 650              	.LVL74:
 651              		.loc 1 414 8 discriminator 1 view .LVU197
 652 001e 2860     		str	r0, [r5]
 415:base64url.c   ****   if (!*out)
 653              		.loc 1 415 3 is_stmt 1 view .LVU198
 654              		.loc 1 415 6 is_stmt 0 view .LVU199
 655 0020 98B1     		cbz	r0, .L54
 656 0022 0246     		mov	r2, r0
 416:base64url.c   ****     return true;
 417:base64url.c   **** 
 418:base64url.c   ****   if (!base64_decode (in, inlen, *out, &needlen))
 657              		.loc 1 418 3 is_stmt 1 view .LVU200
 658              		.loc 1 418 8 is_stmt 0 view .LVU201
 659 0024 01AB     		add	r3, sp, #4
 660 0026 2146     		mov	r1, r4
 661 0028 3846     		mov	r0, r7
 662 002a FFF7FEFF 		bl	base64_decode
 663              	.LVL75:
 664              		.loc 1 418 6 discriminator 1 view .LVU202
 665 002e 0446     		mov	r4, r0
 666              	.LVL76:
 667              		.loc 1 418 6 discriminator 1 view .LVU203
 668 0030 28B1     		cbz	r0, .L56
 419:base64url.c   ****     {
 420:base64url.c   ****       free (*out);
 421:base64url.c   ****       *out = NULL;
 422:base64url.c   ****       return false;
 423:base64url.c   ****     }
 424:base64url.c   **** 
 425:base64url.c   ****   if (outlen)
 669              		.loc 1 425 3 is_stmt 1 view .LVU204
 670              		.loc 1 425 6 is_stmt 0 view .LVU205
 671 0032 0EB1     		cbz	r6, .L52
 426:base64url.c   ****     *outlen = needlen;
 672              		.loc 1 426 5 is_stmt 1 view .LVU206
 673              		.loc 1 426 13 is_stmt 0 view .LVU207
 674 0034 019B     		ldr	r3, [sp, #4]
 675 0036 3360     		str	r3, [r6]
 676              	.L52:
 427:base64url.c   **** 
 428:base64url.c   ****   return true;
 429:base64url.c   **** }
 677              		.loc 1 429 1 view .LVU208
 678 0038 2046     		mov	r0, r4
 679 003a 03B0     		add	sp, sp, #12
 680              	.LCFI5:
 681              		.cfi_remember_state
 682              		.cfi_def_cfa_offset 20
 683              		@ sp needed
 684 003c F0BD     		pop	{r4, r5, r6, r7, pc}
 685              	.LVL77:
 686              	.L56:
 687              	.LCFI6:
 688              		.cfi_restore_state
 420:base64url.c   ****       *out = NULL;
 689              		.loc 1 420 7 is_stmt 1 view .LVU209
 690 003e 2868     		ldr	r0, [r5]
 691 0040 FFF7FEFF 		bl	free
 692              	.LVL78:
 421:base64url.c   ****       return false;
 693              		.loc 1 421 7 view .LVU210
 421:base64url.c   ****       return false;
 694              		.loc 1 421 12 is_stmt 0 view .LVU211
 695 0044 0023     		movs	r3, #0
 696 0046 2B60     		str	r3, [r5]
 422:base64url.c   ****     }
 697              		.loc 1 422 7 is_stmt 1 view .LVU212
 422:base64url.c   ****     }
 698              		.loc 1 422 14 is_stmt 0 view .LVU213
 699 0048 F6E7     		b	.L52
 700              	.LVL79:
 701              	.L54:
 416:base64url.c   **** 
 702              		.loc 1 416 12 view .LVU214
 703 004a 0124     		movs	r4, #1
 704              	.LVL80:
 416:base64url.c   **** 
 705              		.loc 1 416 12 view .LVU215
 706 004c F4E7     		b	.L52
 707              		.cfi_endproc
 708              	.LFE5:
 710              		.section	.rodata
 711              		.align	2
 712              		.set	.LANCHOR0,. + 0
 715              	b64str.0:
 716 0000 41424344 		.ascii	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxy"
 716      45464748 
 716      494A4B4C 
 716      4D4E4F50 
 716      51525354 
 717 0033 7A303132 		.ascii	"z0123456789-_"
 717      33343536 
 717      3738392D 
 717      5F
 720              	b64:
 721 0040 FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 721      FFFFFFFF 
 721      FFFFFFFF 
 721      FF
 722 004d FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 722      FFFFFFFF 
 722      FFFFFFFF 
 722      FF
 723 005a FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 723      FFFFFFFF 
 723      FFFFFFFF 
 723      FF
 724 0067 FFFFFFFF 		.ascii	"\377\377\377\377\377\377>\377\377456789:;<=\377\377"
 724      FFFF3EFF 
 724      FF343536 
 724      3738393A 
 724      3B3C3DFF 
 725 007c FFFFFFFF 		.ascii	"\377\377\377\377\377\000\001\002\003\004\005\006\007"
 725      FF000102 
 725      03040506 
 725      07
 726 0089 08090A0B 		.ascii	"\010\011\012\013\014\015\016\017\020\021\022\023\024"
 726      0C0D0E0F 
 726      10111213 
 726      14
 727 0096 15161718 		.ascii	"\025\026\027\030\031\377\377\377\377?\377\032\033\034"
 727      19FFFFFF 
 727      FF3FFF1A 
 727      1B1C
 728 00a4 1D1E1F20 		.ascii	"\035\036\037 !\"#$%&'()*+,-./0123\377\377\377\377\377"
 728      21222324 
 728      25262728 
 728      292A2B2C 
 728      2D2E2F30 
 729 00c0 FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 729      FFFFFFFF 
 729      FFFFFFFF 
 729      FF
 730 00cd FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 730      FFFFFFFF 
 730      FFFFFFFF 
 730      FF
 731 00da FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 731      FFFFFFFF 
 731      FFFFFFFF 
 731      FF
 732 00e7 FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 732      FFFFFFFF 
 732      FFFFFFFF 
 732      FF
 733 00f4 FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 733      FFFFFFFF 
 733      FFFFFFFF 
 733      FF
 734 0101 FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 734      FFFFFFFF 
 734      FFFFFFFF 
 734      FF
 735 010e FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 735      FFFFFFFF 
 735      FFFFFFFF 
 735      FF
 736 011b FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 736      FFFFFFFF 
 736      FFFFFFFF 
 736      FF
 737 0128 FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377\377\377"
 737      FFFFFFFF 
 737      FFFFFFFF 
 737      FF
 738 0135 FFFFFFFF 		.ascii	"\377\377\377\377\377\377\377\377\377\377\377"
 738      FFFFFFFF 
 738      FFFFFF
 739              		.text
 740              	.Letext0:
 741              		.file 2 "/usr/arm-none-eabi/include/stdlib.h"
 742              		.file 3 "/usr/lib/gcc/arm-none-eabi/14.2.0/include/stddef.h"
DEFINED SYMBOLS
                            *ABS*:00000000 base64url.c
     /tmp/ccgMN135.s:20     .text.base64_encode:00000000 $t
     /tmp/ccgMN135.s:26     .text.base64_encode:00000000 base64_encode
     /tmp/ccgMN135.s:229    .text.base64_encode:000000d0 $d
     /tmp/ccgMN135.s:234    .text.base64_encode_alloc:00000000 $t
     /tmp/ccgMN135.s:240    .text.base64_encode_alloc:00000000 base64_encode_alloc
     /tmp/ccgMN135.s:317    .text.base64_encode_alloc:00000044 $d
     /tmp/ccgMN135.s:322    .text.isbase64:00000000 $t
     /tmp/ccgMN135.s:328    .text.isbase64:00000000 isbase64
     /tmp/ccgMN135.s:351    .text.isbase64:00000010 $d
     /tmp/ccgMN135.s:356    .text.base64_decode:00000000 $t
     /tmp/ccgMN135.s:362    .text.base64_decode:00000000 base64_decode
     /tmp/ccgMN135.s:603    .text.base64_decode:000000b4 $d
     /tmp/ccgMN135.s:608    .text.base64_decode_alloc:00000000 $t
     /tmp/ccgMN135.s:614    .text.base64_decode_alloc:00000000 base64_decode_alloc
     /tmp/ccgMN135.s:711    .rodata:00000000 $d
     /tmp/ccgMN135.s:715    .rodata:00000000 b64str.0
     /tmp/ccgMN135.s:720    .rodata:00000040 b64
                           .group:00000000 wm4.0.72866714a5966c404084f8c69e3df25d
                           .group:00000000 wm4.stdbool.h.29.c08aa3eec75cf5b9b5003883f43253f0
                           .group:00000000 wm4.stddef.h.39.38eb7ec030421799c657b13be5aa21c7
                           .group:00000000 wm4.base64url.h.26.ed1fee22e760dd991443f292d5830091
                           .group:00000000 wm4.ieeefp.h.77.61a77db5804869b1dadd307a77cf78c9
                           .group:00000000 wm4._newlib_version.h.4.0eb654b64686e2bd29646258853f6c22
                           .group:00000000 wm4.newlib.h.27.a82728f74da661df333d09507bfef510
                           .group:00000000 wm4.features.h.22.03467e2205ec9ffbc20524d97cdbdf6a
                           .group:00000000 wm4.config.h.224.10ee1ad185d877c6e334e6581faab44d
                           .group:00000000 wm4._ansi.h.31.de524f58584151836e90d8620a16f8e8
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.stddef.h.158.eec8bf00b5213f43d095cb984c5f22e3
                           .group:00000000 wm4._default_types.h.6.959254cf5f09734ea7516c89e8bb21bd
                           .group:00000000 wm4.cdefs.h.49.bafb023044e47a1dcdd854e4d6521f7d
                           .group:00000000 wm4._types.h.20.dd0d04dca3800a0d2a6129b87f3adbb2
                           .group:00000000 wm4.stddef.h.158.6f8e08a347b1cff664332fa350bfceb3
                           .group:00000000 wm4._types.h.127.3bdfe3ff8ea2d0985b03d9cbe93480e3
                           .group:00000000 wm4.reent.h.18.25503cdc8b7e55dd0d6ea7b3e5af7a03
                           .group:00000000 wm4.lock.h.2.1461d1fff82dffe8bfddc23307f6484f
                           .group:00000000 wm4.reent.h.78.6b87466b04591b1f1cb88c14fdf2ba9e
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.56.f4862cfbf4363a1db01842d5bdf72c18
                           .group:00000000 wm4.syslimits.h.34.de5cbd310098bc5895998b6bde577ed2
                           .group:00000000 wm4.limits.h.9.70fb0ada6f71b16202a66baaa6d8ea70
                           .group:00000000 wm4.limits.h.60.56a1ae353e2028a24298ec6463b8b593

UNDEFINED SYMBOLS
malloc
free
